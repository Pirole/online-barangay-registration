// src/types/database.ts
// Re-export Prisma types for easier importing throughout the app

// First, make sure Prisma client is generated by running: npx prisma generate

import type {
  User,
  Event,
  Registrant,
  OtpCode,
  AttendanceLog,
  AuditLog,
  TempPhoto,
  SystemSetting,
  UserRole,
  RegistrantStatus,
  AuditAction,
  Prisma,
  PrismaClient
} from '@prisma/client';

// Re-export main types
export type {
  User,
  Event,
  Registrant,
  OtpCode,
  AttendanceLog,
  AuditLog,
  TempPhoto,
  SystemSetting,
  UserRole,
  RegistrantStatus,
  AuditAction,
  Prisma,
  PrismaClient
};

// Custom types for API responses and extended functionality
export interface UserWithEvents extends User {
  managedEvents?: Event[];
  registrants?: Registrant[];
}

export interface EventWithDetails extends Event {
  manager: User;
  registrants?: Registrant[];
  _count?: {
    registrants: number;
    attendanceLogs: number;
  };
}

export interface RegistrantWithRelations extends Registrant {
  event?: Event;
  user?: User;
  otpCodes?: OtpCode[];
  attendanceLogs?: AttendanceLog[];
}

export interface AttendanceLogWithDetails extends AttendanceLog {
  registrant: Registrant;
  event: Event;
  scannedBy: User;
}

export interface AuditLogWithActor extends AuditLog {
  actor?: User;
}

// API Response types
export interface ApiResponse<T = any> {
  success: boolean;
  data?: T;
  message?: string;
  error?: string;
}

export interface PaginatedResponse<T = any> {
  success: boolean;
  data: T[];
  pagination: {
    page: number;
    limit: number;
    total: number;
    totalPages: number;
    hasNextPage: boolean;
    hasPrevPage: boolean;
  };
}

// Custom field definitions
export interface CustomField {
  key: string;
  label: string;
  type: 'text' | 'number' | 'select' | 'checkbox' | 'textarea';
  required: boolean;
  options?: string[];
  validation?: string; // regex pattern
  placeholder?: string;
  helperText?: string;
}

// JWT payload types
export interface JwtPayload {
  userId: string;
  email: string;
  role: UserRole;
  iat: number;
  exp: number;
}

export interface RefreshTokenPayload {
  userId: string;
  tokenId: string;
  iat: number;
  exp: number;
}

// OTP types
export interface OtpResponse {
  success: boolean;
  message: string;
  expiresAt: Date;
  attemptsLeft: number;
}

// Photo upload types
export interface PhotoUpload {
  id: string;
  filename: string;
  filepath: string;
  url?: string;
  size: number;
  mimetype: string;
}

// QR Code data structure
export interface QrCodeData {
  registrantId: string;
  eventId: string;
  issuedAt: number;
  expiresAt: number;
  signature?: string;
}

// Event statistics
export interface EventStats {
  totalEvents: number;
  upcomingEvents: number;
  ongoingEvents: number;
  completedEvents: number;
  totalRegistrants: number;
  approvedRegistrants: number;
  pendingRegistrants: number;
  rejectedRegistrants: number;
}

// System configuration
export interface SystemConfig {
  maxFileSize: number;
  allowedImageTypes: string[];
  otpExpiryMinutes: number;
  otpMaxAttempts: number;
  jwtExpiresIn: string;
  jwtRefreshExpiresIn: string;
  auditLogRetentionDays: number;
  bcryptRounds: number;
}

// Database connection types
export interface DatabaseConfig {
  host: string;
  port: number;
  database: string;
  username: string;
  password: string;
  ssl?: boolean;
  connectionLimit?: number;
}

// SMS Provider types
export interface SmsProvider {
  sendOtp(phone: string, code: string): Promise<boolean>;
  getDeliveryStatus?(messageId: string): Promise<'delivered' | 'failed' | 'pending'>;
}

export interface TextBeeConfig {
  apiKey: string;
  deviceId: string;
  baseUrl?: string;
}

// Audit log metadata types
export type AuditMetadata = {
  oldValues?: Record<string, any>;
  newValues?: Record<string, any>;
  ipAddress?: string;
  userAgent?: string;
  additionalInfo?: Record<string, any>;
};

// Event filters and search
export interface EventFilters {
  search?: string;
  status?: 'upcoming' | 'ongoing' | 'completed';
  managerId?: string;
  startDate?: string;
  endDate?: string;
  capacity?: {
    min?: number;
    max?: number;
  };
  ageRange?: {
    min?: number;
    max?: number;
  };
}

// Registrant filters
export interface RegistrantFilters {
  eventId?: string;
  status?: RegistrantStatus;
  search?: string;
  ageRange?: {
    min?: number;
    max?: number;
  };
  barangay?: string;
  registrationDate?: {
    from?: string;
    to?: string;
  };
}

// Export utility types for Prisma operations
export type UserCreateInput = Prisma.UserCreateInput;
export type UserUpdateInput = Prisma.UserUpdateInput;
export type UserWhereInput = Prisma.UserWhereInput;
export type UserSelect = Prisma.UserSelect;
export type UserInclude = Prisma.UserInclude;

export type EventCreateInput = Prisma.EventCreateInput;
export type EventUpdateInput = Prisma.EventUpdateInput;
export type EventWhereInput = Prisma.EventWhereInput;
export type EventSelect = Prisma.EventSelect;
export type EventInclude = Prisma.EventInclude;

export type RegistrantCreateInput = Prisma.RegistrantCreateInput;
export type RegistrantUpdateInput = Prisma.RegistrantUpdateInput;
export type RegistrantWhereInput = Prisma.RegistrantWhereInput;
export type RegistrantSelect = Prisma.RegistrantSelect;
export type RegistrantInclude = Prisma.RegistrantInclude;

// Database transaction type
export type DatabaseTransaction = Omit<PrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>;

// Error types
export class DatabaseError extends Error {
  constructor(message: string, public code?: string) {
    super(message);
    this.name = 'DatabaseError';
  }
}

export class ValidationError extends Error {
  constructor(message: string, public field?: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

export class AuthenticationError extends Error {
  constructor(message: string = 'Authentication failed') {
    super(message);
    this.name = 'AuthenticationError';
  }
}

export class AuthorizationError extends Error {
  constructor(message: string = 'Insufficient permissions') {
    super(message);
    this.name = 'AuthorizationError';
  }
}